#!/usr/bin/ruby

require 'yaml'
require 'open4'
require 'rubytui'
require 'fcntl'
include RubyTUI
require 'tempfile'
require 'bytes'
require 'rbconfig'
require 'disktestlog'

# Environment variables that disktest pays attention to:
# * DISKTEST_REQUIRED_NUMBER_OF_DRIVES
# * DISKTEST_ALLOW_LESS_THAN_REQUIRED
# * DISKTEST_DISK_REGEX
# * DISKTEST_SCSI_REGEX
# * DISKTEST_LOGTO_FGDB

def clear_stdin(parent = true)
  flags=$stdin.fcntl(Fcntl::F_GETFL)
  if parent
    while clear_stdin(false)
      nil
    end
  else
    begin
      $stdin.read_nonblock(10000000)
      return true
    rescue Errno::EAGAIN
      return false
    ensure
      $stdin.fcntl(Fcntl::F_SETFL, flags)
    end
  end
end

class HardDrive
  PASSED = 0
  FAILED = 1
  UNTESTED = 2
  REVERSE = {"0" => "PASSED", "1" => "FAILED", "2" => "UNTESTED"}

  def HardDrive.modules
    @@modules ||= case (arch = Config::CONFIG["arch"].split("-")[0])
                  when "i486", "x86_64"
                    %w[ide_core ide_disk ide_generic usb_storage]
                  when "powerpc"
                    %w[ide_disk usb_storage]
                  else
                    errorMessage("Unsupported architecture: #{arch}\n")
                    exit!(1)
                  end
  end

  def HardDrive.scan
    mnt = `mount`
    loaded_modules = `lsmod`.split("\n")[1..-1].map{|x| x.split(' ').first}
    (HardDrive.modules - loaded_modules).each{|x|
      if ! system("modprobe #{x}")
        errorMessage("Could not load required module: #{x}\n")
        exit!(1)
      end
    }
    Dir.open('/sys/block').find_all {|dev|
      (ENV['DISKTEST_DISK_REGEX'] ? /#{ENV['DISKTEST_DISK_REGEX']}/ : /^[sh]d[a-z]/).match(dev) and
      `cat /sys/block/#{dev}/removable`.chomp == '0' and
      ! mnt.include?(dev)
    }.map {|dev| HardDrive.new(dev)}
  end

  def initialize(dev)
    @dev = dev
    @lshw_this = nil
    @testing = false
    @status = UNTESTED
    @log = []
    @size = `cat /sys/block/#{dev}/size`.chomp.to_i * 512
    @started = @finished = nil
  end
  attr_reader :dev, :size
  attr_accessor :finished, :testing, :log
  attr_writer :status
  attr_reader :disktest_run

  def run_tests
    return if @testing
    @testing = true
    @started = Time.new
    @disktest_run = DisktestLog.new(vendor, model_name, serial)
    @thread = Thread.new(self) {|drive|
      begin
        if(drive.smart &&
           drive.smarttest &&
           drive.smart && 
           drive.badblocks &&
           drive.smart &&
           drive.wipe &&
           drive.smart)
          drive.status = PASSED
        end
      rescue Exception => e
        drive.log << e
        drive.log << e.backtrace
        drive.status = FAILED
      ensure
        drive.testing = false
        drive.finished = Time.new
        drive.disktest_run.complete(REVERSE[@status.to_s])
      end
    }
    @thread.abort_on_exception = true
    return @thread
  end
  
  def smarttest
    log << "initiating smart self-test"
    system('/usr/sbin/smartctl', '-q', 'silent', '-t', 'short', "/dev/#{dev}")
    # always return true, in case we're testing a drive without smart support.
    return true
  end

  def smart
    is_ata=true
    scsi_regex = (ENV['DISKTEST_SCSI_REGEX'] ? ENV['DISKTEST_SCSI_REGEX'] : "sd[a-z]" )
    if /^#{scsi_regex}$/.match(dev)
      is_ata=`lsscsi`.select{|x| x.match(dev)}.first.split(" ")[2] == "ATA"
    end
    if is_ata
      system('/usr/sbin/smartctl', '-q', 'silent', '--all', '-d', 'ata', "/dev/#{dev}")
    else
      system('/usr/sbin/smartctl', '-q', 'silent', '--all', "/dev/#{dev}")
    end
    retval=$?.exitstatus
    if retval != 0
      log << "smart test returned: '#{retval}'"
      if retval > 4
        @status = FAILED
        return false
      end
    end
    log << "smart test passed"
    return true
  end

  def badblocks
    log << "badblocks test started"
    log << ""
    # progress comes in through err, bad blocks are reported on out
    #bbpid, bbin, bbout, bberr = Open4.popen4("#{File.dirname(__FILE__)}/fake_badblocks -c 1024 -s /dev/#{dev}")
    #bbpid, bbin, bbout, bberr = Open4.popen4("/sbin/badblocks -c 1024 -s /dev/#{dev}")
    bbpid, bbin, bbout, bberr = Open4.popen4("/sbin/badblocks -e 1 -c 1024 -swt 0xffffffff /dev/#{dev}")
    bbout.sync = bberr.sync = true
    current_state = 0
    until bberr.closed? or bberr.eof?
      matches = nil
      statematch = nil
      buff = nil
      reads, writes, errs = IO.select([bbout, bberr], nil, nil, 1)
      if reads
        progress = reads.include?(bberr) ? bberr : nil
        sectors = reads.include?(bbout) ? bbout : nil
      end
      if sectors and ! sectors.eof?
        buff = sectors.read_nonblock(1000)
        # :TODO: find out what this means for sure
        @status = FAILED
        curr = log[-1]
        log[-1] = "badblocks reports failures"
        log << curr
      end
      if progress and ! progress.closed?
        until( statematch or matches or bberr.eof? )
          buff = progress.read_nonblock(1000)
          statematch = %r,^(.*):,.match(buff)
#          matches = %r,(\d+)\s*/\s*(\d+)[^\d]*,.match(buff)
          matches = %r,([\d.]+)%,.match(buff)
        end
        if statematch
          if statematch[1].match(/Testing/)
            current_state = 1
          elsif statematch[1].match(/Reading/)
            current_state = 2
          end
        end
        if matches and current_state > 0
          if current_state == 1
            log[-1] = "#{matches[1].to_f.round}% of badblocks write (part one) complete"
          elsif current_state == 2
            log[-1] = "#{matches[1].to_f.round}% of badblocks read (part two) complete"
          end
        end
      end
      if @status == FAILED
        [bbin, bbout, bberr].each {|io| io.close}
        Process.kill("INT", bbpid)
        break
      end
    end
    stats = Process::waitpid2(bbpid)
    if stats[1] and stats[1].exitstatus and stats[1].exitstatus.nonzero?
      @log << "badblocks failed"
      @status = FAILED
    end
    return @status != FAILED
  end # def badblocks

  ZEROS = "\0" * (1024 * 1024)
  open('/dev/urandom') {|urand| RANDOM = urand.read(1024)}
  def wipe
    log << "disk wipe started..."
    total = 0
    log << ""
    open("/dev/#{dev}", "w") {|drive|
      until drive.closed?
        begin
          written = drive.write(ZEROS)
          total += written
          log[-1] = "#{(total.to_i * 100) / (2 * size.to_i)}% of wipe complete"
          if @status == FAILED or written < ZEROS.length
            break
          end
        rescue Errno::ENOSPC => e
          break
        end
      end
    }
    open("/dev/#{dev}", "w") {|drive|
      until drive.closed?
        begin
          written = drive.write(RANDOM)
          total += written
          log[-1] = "#{(total.to_i * 100) / (2 * size.to_i)}% of wipe complete"
          if @status == FAILED or written < RANDOM.length
            break
          end
        rescue Errno::ENOSPC => e
          break
        end
      end
    }
    log << "disk wipe finished"
    return @status != FAILED
  end

  def output_display
    highlight(dev + ": ")
    echo(status + " - " + time_taken)
  end

  def output_drive_descriptor
    disp_size = size.to_bytes(1, false, false)
    highlight(dev + ": ")
    $stderr.puts colored(disp_size.to_s + unique_identity, "black", "on_yellow")
    $stderr.flush
  end

  def unique_identity
    " <<%s %s (%s)>>" % [vendor, model_name, serial]
  end

  def vendor
    match = self.lshw.match("<vendor>(.*?)</vendor>")
    return match ? match[1] : "Unknown Vendor"
  end

  def model_name
    match = self.lshw.match("<product>(.*?)</product>")
    return match ? match[1] : "Unknown Model"
  end

  def serial
    match = self.lshw.match("<serial>(.*?)</serial>")
    return match ? match[1] : "Unknown Serial"
  end

  # :MC: better done with real xml parsing...
  def lshw
    return @lshw_this if @lshw_this
    @@lshw_full ||= `lshw -xml -class disk 2> /dev/null`
    @@lshw_split ||= @@lshw_full.split('id="disk')
    debugMsg("%d lshw drives found." % @@lshw_split.length)

    @lshw_this = @@lshw_split.find {|node|
      node.match("logicalname>/dev/#{dev}</logicalname")
    }
    if @lshw_this
      debugMsg(@lshw_this)
    else
      @lshw_this = ""
      errorMessage("Could not get the lshw for this (%s) drive." % dev)
#      exit!(1)
    end
    return @lshw_this
  end

  def time_taken
    if @started
      if @finished
        duration = @finished - @started
      else
        duration = Time.new - @started
      end
      "#{duration} seconds"
    else
      "(no time has been recorded yet)"
    end
  end

  def status
    case @status
    when PASSED
      "all tests passed:\n#{log.to_yaml}"
    when FAILED
      "failed:\n#{log.to_yaml}"
    else
      log.last or "unknown status"
    end
  end

  def passed?
    @status == PASSED
  end

  def failed?
    @status == FAILED
  end

  Err_re = /error/
  def klog_match?(line)
    Err_re.match(line) and
      /#{@dev}/.match(line)
  end

  def klog(*msgs)
    return if failed?
    msgs.each do |msg|
      break if failed?
      if klog_match?(msg)
        @status = FAILED
        #:MC: ugly handling of continuously updating progress log entry
        mymsg = "Logged kernel error: " + msg
        if log.length > 0
          curr = log[-1]
          log[-1] = mymsg
          log << curr
        else
          log << mymsg
        end
      end
    end
  end

end

if __FILE__ == $0
  trap( "SIGINT" ) do
    errorMessage "\n\nUser interrupt caught.  Exiting.\n\n"
    exit!( 1 )
  end
  if `id -u` != "0\n"
    errorMessage "This program must be ran as root.\n\n"
    exit 1
  end
  logpipe=""
  logconf=""
  logpipe = Tempfile.new("klog")
  logpipe.close
  logpipe = logpipe.path
  logconf = Tempfile.new("syslog.conf")
  logconf.puts "*.* #{logpipe}"
  #    logconf.puts "*.* /dev/console"
  logconf.close
  logconf = logconf.path
  if File.exists?("/sbin/syslogd")
    `/usr/sbin/invoke-rc.d sysklogd stop`
    `/sbin/syslogd -f #{logconf}`
  elsif File.exists?("/usr/sbin/rsyslogd")
    `/usr/sbin/invoke-rc.d rsyslog stop`
    `/usr/sbin/rsyslogd -f #{logconf}`
  else
    errorMessage "You need to install a supported syslog daemon.\n\n"
    exit 1
  end
  klpid, klin, klout, klerr = open4("tail -F #{logpipe}")
  loglines = []
  loglines += `dmesg`.split("\n")
  clearer = `clear`
  drives = HardDrive.scan.sort_by {|d| d.dev}
  begin
    $stderr.write(clearer)
    $stderr.flush
    drives.each {|d|
      d.output_drive_descriptor
    }
    RubyTUI::PromptColor.replace(["magenta", "bold"])
    promptWithDefault("Are these the expected drives and do you want to test them?", "yes", "Type 'yes' to begin") do |response|
      /^y/.match(response)
    end
    required = 2
    if ENV['DISKTEST_REQUIRED_NUMBER_OF_DRIVES']
        required = ENV['DISKTEST_REQUIRED_NUMBER_OF_DRIVES'].to_i
    end
    if drives.size < required && ENV['DISKTEST_ALLOW_LESS_THAN_REQUIRED'] != "true"
      errorMessage("There are #{drives.size} drives! at least #{required} were expected.\n")
      promptWithDefault("Are you sure you want to continue?", "no", "Type 'yes, I want to test #{drives.size} drive(s)' to continue anyway or 'no' to abort the disktest.") do |output|
        if output == nil || output == '' || output.match(/^no$/)
          errorMessage("Aborted.\n")
          exit
        end
        output.match(/^yes, I want to test . drive\(s\)$/)
      end
    end
    threads = drives.map {|drive| drive.run_tests}
    until threads.empty?
      if select([klout],nil,nil,0.1)
        loglines += klout.read_nonblock(1000).split("\n")
      end
      loglines.flatten!
      drives.each {|d|
        d.klog(*loglines)
        d.output_display
      }
      loglines.clear
      threads = threads.find_all {|t|
        t.alive?
      }
      sleep 1
      $stderr.write(clearer)
      $stderr.flush
    end
  ensure
    Process::kill(9, klpid)
    header "Final status:"
    drives.each {|d|
      d.output_display
    }
    drives.each {|d|
      if d.passed?
        d.output_drive_descriptor
        puts colored( "#{d.dev} passed!  Label and store it.", 'bold', 'black', 'on_green' )
      elsif d.failed?
        errorMessage "#{d.dev} failed.  Recycle it.\n"
      else
        d.output_drive_descriptor
        errorMessage "#{d.dev} did not finish testing.  Seek expert attention.\n"
      end
    }
    clear_stdin
  end
end
